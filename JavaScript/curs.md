## Строгое сравнение строк
Как же быть, если есть два значения разных типов, а на приведение по умолчанию надеяться не хочется? Использовать приведение «руками».

Например, можно привести числовое значение к строковому типу. Один из способов — использовать команду число.toString(). Например
```
var number = 1;

// Выведет число: 1 (number)
console.log(number);

// Выведет строку: "1" (string)
console.log(number.toString());
```
## Строгое сравнение чисел
Привести число к строке можно с помощью команды .toString(). Но иногда, наоборот, требуется превратить строку в число, чтобы сравнить их.

Для этого можно использовать команду parseInt(). Пример:

```
var string = '1';

console.log(string);
// выведет строку: "1" (string)

console.log(parseInt(string, 10));
// выведет число: 1 (number)
```
Обратите внимание, что у команды два аргумента:

строка, которую мы пытаемся превратить в число;
основание системы счисления, в которую мы переводим число.
Мы привыкли работать в десятичной системе счисления, но в программировании часто приходится иметь дело с другими системами: двоичной, восьмеричной, шестнадцатеричной. Именно поэтому у parseInt() есть второй аргумент. И хотя сейчас мы не будем разбираться в тонкостях систем счисления, не забывайте про эту особенность команды parseInt() и всегда явно указывайте второй аргумент, чтобы избежать ошибок.
```
var string = '123';
var number = 123;

if (parseInt(string, 10) === number) {
  console.log('Сравнение заработало!');
} else {
  console.log('Не могу сравнить');
}
```
## Значения как условие

Главное — понимать, как эти значения приводятся к логическому типу. Если true и false остаются собой, то числа и строки приводятся по-особому. Например, все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false. Можно сказать, что значения, которые как бы ничего в себе не содержат (как 0 или пустая строка ''), приводятся к false, а все остальные приводятся к true.
```
if ('какая-то строка') {
  // Непустая строка приводится к true
  // Условие выполнится
};

if ('') {
  // Пустая строка приводится к false
  // Условие не выполнится
};

if (123) {
  // Число приводится к true
  // Условие выполнится
};

if (0) {
  // 0 приводится к false
  // Условие не выполнится
};
```
## Логическое отрицание
В этих условиях есть ключевое слово «нет», а значит они должны выполняться в тех случаях, когда значение переменной false и не выполняться, если значение — true.

Чтобы создать проверки с отрицанием используют унарный (одноместный) логический оператор !. Пример:
```
var condition = false;

if (!condition) {
  // код выполнится
}
```

## Конспект «Условия»
### Синтаксис
Условие:
```
if (условие) {
  действие;
}
```
Условие с альтернативным действием:
```
if (условие) {
  действия;
} else {
  другие действия;
}
```
Вложенные условия:
```
if (условие1) {
  if (условие2) {
    действия;
  }
}
```
### Как работают условия
Операторы сравнения:> , < , >= , <= .
Операторы равенства: = , == , ===, !=, !==.

Любые значения внутри проверок приводятся к булеву типу. Все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false.

Логические операторы.

* Оператор && или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true.

* Оператор || или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true.

* Оператор ! или «логическое отрицание» меняет булево значение выражения справа от него на противоположное.

## Несколько удобных операторов, которые позволяют сократить код. Вот они:

Инкремент (увеличение на единицу)	

    i++	

    i = i + 1

Декремент (уменьшение на единицу)

	i--
  
  	i = i - 1

К-к-комбо!

	i += 2
  
  	i = i + 2

Комбинировать можно не только сложение, но и остальные математические операции: вычитание -=, умножение *=, деление /= и нахождение остатка %=. Например, i *= 10 будет аналогично i = i * 10.

### Выведем только нечётные страницы.
```js
var totalPages = 7;

for (var page = 1; page <= totalPages; page+=2) {
  keks.print(page);
}

```
### Теперь выведем только чётные страницы.

```js
var totalPages = 9;

for (var page = 2; page <= totalPages; page += 2) {
  keks.print(page);
}

```
### режим копий
```js
var mode = 'pageCopy'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 3; // Количество копий

if (mode === 'pageCopy') {
  for (var copies = 1; copies <= copyCount; copies = copies + 1) {
      keks.print(pageNumber)
    }
}

  ```
### все страницы

```js
var mode = 'document'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 6; // Всего страниц в документе


if (mode === 'document') {
    for (var page = 1; page <= totalPages; page+=1) {
        keks.print(page);
      }
  }

```
###  страницы в обратном порядке
«...цикл, который уменьшает значение переменной i от 10 до 1 включительно». Это значит, что цикл закончит свою работу, когда i станет равно 0. При i = 1 цикл совершит очередную итерацию. Так как стартовое значение счётчика 10 и оно будет уменьшаться до 1 включительно, нам подойдёт знак «больше или равно». Сранивать будем с 1 так как это значение, после которого цикл должен остановиться.
```js
for (var i = 10; i >= 1;) {
  …
}
```
Обратите внимание, что условие можно написать и немного по-другому. Если нам нужно учесть значение 1, но при значении меньше 1 закончить работу цикла, то можно использовать знак «больше». Только сравнивать его с 0. Тогда единица точно будет использоваться в качестве значения счётчика, а при 0 цикл закончит свою работу.
```js
for (var i = 10; i > 0;) {
  …
}
```

```js
var mode = 'reverse'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 6; // Всего страниц в документе



if (mode === 'reverse') {
    for (var reversePage = totalPages; reversePage > 0; reversePage = reversePage - 1) {
        keks.print(reversePage);
      }
  }
  ```

  ### Драйвер печати: чётные и нечётные страницы
  ```js
  var mode = 'alternate'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 5; // Всего страниц в документе
var startPage = 1; // Стартовая страница

if (mode === 'alternate') {
  for (var alternatePage = startPage; alternatePage <= totalPages; alternatePage += 2) {
       keks.print( alternatePage);
  }
}

```
Для выбора между чётностью и нечётностью выводимых страниц будем использовать переменную startPage — если она равна 1, выводятся нечётные страницы, если 2 — чётные.
### Накопление в цикле
Число 4 выведется в консоль 5 раз, ведь именно столько итераций в этом цикле. То есть на каждой итерации двойки будут складываться и выводиться в консоль. Но если на каждой итерации нам нужно получать новое, увеличенное, число, надо действовать по-другому. Нужно завести перед циклом ещё одну переменную, которая и будет хранить сумму:
```js
var sum = 0;

for (var i = 1; i <= 5; i++) {
  sum += 2;
  console.log(sum);
}
```
```
LOG: 2 (number)
LOG: 4 (number)
LOG: 6 (number)
LOG: 8 (number)
LOG: 10 (number)
```
### Проверки в циклах
```js
var sum = 0;

for (var i = 1; i <= 5; i++) {
  if (i > 2) {
    sum += 3;
  } else {
    sum += 2;
  }
  console.log(sum);
}

```
```
LOG: 2 (number)
LOG: 4 (number)
LOG: 7 (number)
LOG: 10 (number)
LOG: 13 (number)
```

### Поиск чётного числа

Как проверить, что число чётное? Здесь может помочь оператор %. Он называется остаток от деления и, как понятно из названия, возвращает остаток от деления.
```
10 % 5;  // Вернёт 0
12 % 5;  // Вернёт 2
7 % 3;   // Вернёт 1
5.5 % 2; // Вернёт 1.5
```
Как это поможет в определении чётного или нечётного числа? Чётное число делится на 2 без остатка. Поэтому, если деление i % 2 возвращает 0 — число чётное, иначе число нечётное.

Напишем проверку с использованием **%** в нашем цикле.
```js
var sum = 0;

for (var i = 1; i <= 10; i++) {
  console.log('i: ' + i);

  // Проверку добавляйте сюда
  if (i % 2 === 0 ) {
      sum += 2;
      console.log('чётное число');
    } else {
        sum += 1;
        console.log('нечётное число');
      }
    

  console.log('sum: ' + sum);
}

```
