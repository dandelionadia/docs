## Строгое сравнение строк
Как же быть, если есть два значения разных типов, а на приведение по умолчанию надеяться не хочется? Использовать приведение «руками».

Например, можно привести числовое значение к строковому типу. Один из способов — использовать команду число.toString(). Например
```
var number = 1;

// Выведет число: 1 (number)
console.log(number);

// Выведет строку: "1" (string)
console.log(number.toString());
```
## Строгое сравнение чисел
Привести число к строке можно с помощью команды .toString(). Но иногда, наоборот, требуется превратить строку в число, чтобы сравнить их.

Для этого можно использовать команду parseInt(). Пример:

```
var string = '1';

console.log(string);
// выведет строку: "1" (string)

console.log(parseInt(string, 10));
// выведет число: 1 (number)
```
Обратите внимание, что у команды два аргумента:

строка, которую мы пытаемся превратить в число;
основание системы счисления, в которую мы переводим число.
Мы привыкли работать в десятичной системе счисления, но в программировании часто приходится иметь дело с другими системами: двоичной, восьмеричной, шестнадцатеричной. Именно поэтому у parseInt() есть второй аргумент. И хотя сейчас мы не будем разбираться в тонкостях систем счисления, не забывайте про эту особенность команды parseInt() и всегда явно указывайте второй аргумент, чтобы избежать ошибок.
```
var string = '123';
var number = 123;

if (parseInt(string, 10) === number) {
  console.log('Сравнение заработало!');
} else {
  console.log('Не могу сравнить');
}
```
## Значения как условие

Главное — понимать, как эти значения приводятся к логическому типу. Если true и false остаются собой, то числа и строки приводятся по-особому. Например, все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false. Можно сказать, что значения, которые как бы ничего в себе не содержат (как 0 или пустая строка ''), приводятся к false, а все остальные приводятся к true.
```
if ('какая-то строка') {
  // Непустая строка приводится к true
  // Условие выполнится
};

if ('') {
  // Пустая строка приводится к false
  // Условие не выполнится
};

if (123) {
  // Число приводится к true
  // Условие выполнится
};

if (0) {
  // 0 приводится к false
  // Условие не выполнится
};
```
## Логическое отрицание
В этих условиях есть ключевое слово «нет», а значит они должны выполняться в тех случаях, когда значение переменной false и не выполняться, если значение — true.

Чтобы создать проверки с отрицанием используют унарный (одноместный) логический оператор !. Пример:
```
var condition = false;

if (!condition) {
  // код выполнится
}
```

## Конспект «Условия»
### Синтаксис
Условие:
```
if (условие) {
  действие;
}
```
Условие с альтернативным действием:
```
if (условие) {
  действия;
} else {
  другие действия;
}
```
Вложенные условия:
```
if (условие1) {
  if (условие2) {
    действия;
  }
}
```
### Как работают условия
Операторы сравнения:> , < , >= , <= .
Операторы равенства: = , == , ===, !=, !==.

Любые значения внутри проверок приводятся к булеву типу. Все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false.

Логические операторы.

* Оператор && или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true.

* Оператор || или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true.

* Оператор ! или «логическое отрицание» меняет булево значение выражения справа от него на противоположное.

## Несколько удобных операторов, которые позволяют сократить код. Вот они:

Инкремент (увеличение на единицу)	

    i++	

    i = i + 1

Декремент (уменьшение на единицу)

	i--
  
  	i = i - 1

К-к-комбо!

	i += 2
  
  	i = i + 2

Комбинировать можно не только сложение, но и остальные математические операции: вычитание -=, умножение *=, деление /= и нахождение остатка %=. Например, i *= 10 будет аналогично i = i * 10.

### Выведем только нечётные страницы.
```js
var totalPages = 7;

for (var page = 1; page <= totalPages; page+=2) {
  keks.print(page);
}

```
### Теперь выведем только чётные страницы.

```js
var totalPages = 9;

for (var page = 2; page <= totalPages; page += 2) {
  keks.print(page);
}

```
### режим копий
```js
var mode = 'pageCopy'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 3; // Количество копий

if (mode === 'pageCopy') {
  for (var copies = 1; copies <= copyCount; copies = copies + 1) {
      keks.print(pageNumber)
    }
}

  ```
### все страницы

```js
var mode = 'document'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 6; // Всего страниц в документе


if (mode === 'document') {
    for (var page = 1; page <= totalPages; page+=1) {
        keks.print(page);
      }
  }

```
###  страницы в обратном порядке
«...цикл, который уменьшает значение переменной i от 10 до 1 включительно». Это значит, что цикл закончит свою работу, когда i станет равно 0. При i = 1 цикл совершит очередную итерацию. Так как стартовое значение счётчика 10 и оно будет уменьшаться до 1 включительно, нам подойдёт знак «больше или равно». Сранивать будем с 1 так как это значение, после которого цикл должен остановиться.
```js
for (var i = 10; i >= 1;) {
  …
}
```
Обратите внимание, что условие можно написать и немного по-другому. Если нам нужно учесть значение 1, но при значении меньше 1 закончить работу цикла, то можно использовать знак «больше». Только сравнивать его с 0. Тогда единица точно будет использоваться в качестве значения счётчика, а при 0 цикл закончит свою работу.
```js
for (var i = 10; i > 0;) {
  …
}
```

```js
var mode = 'reverse'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 6; // Всего страниц в документе



if (mode === 'reverse') {
    for (var reversePage = totalPages; reversePage > 0; reversePage = reversePage - 1) {
        keks.print(reversePage);
      }
  }
  ```

  ### Драйвер печати: чётные и нечётные страницы
  ```js
  var mode = 'alternate'; // Режим работы драйвера печати
var pageNumber = 5; // Номер копируемой страницы
var copyCount = 7; // Количество копий
var totalPages = 5; // Всего страниц в документе
var startPage = 1; // Стартовая страница

if (mode === 'alternate') {
  for (var alternatePage = startPage; alternatePage <= totalPages; alternatePage += 2) {
       keks.print( alternatePage);
  }
}

```
Для выбора между чётностью и нечётностью выводимых страниц будем использовать переменную startPage — если она равна 1, выводятся нечётные страницы, если 2 — чётные.
### Накопление в цикле
Число 4 выведется в консоль 5 раз, ведь именно столько итераций в этом цикле. То есть на каждой итерации двойки будут складываться и выводиться в консоль. Но если на каждой итерации нам нужно получать новое, увеличенное, число, надо действовать по-другому. Нужно завести перед циклом ещё одну переменную, которая и будет хранить сумму:
```js
var sum = 0;

for (var i = 1; i <= 5; i++) {
  sum += 2;
  console.log(sum);
}
```
```
LOG: 2 (number)
LOG: 4 (number)
LOG: 6 (number)
LOG: 8 (number)
LOG: 10 (number)
```
### Проверки в циклах
```js
var sum = 0;

for (var i = 1; i <= 5; i++) {
  if (i > 2) {
    sum += 3;
  } else {
    sum += 2;
  }
  console.log(sum);
}

```
```
LOG: 2 (number)
LOG: 4 (number)
LOG: 7 (number)
LOG: 10 (number)
LOG: 13 (number)
```

### Поиск чётного числа

Как проверить, что число чётное? Здесь может помочь оператор %. Он называется остаток от деления и, как понятно из названия, возвращает остаток от деления.
```
10 % 5;  // Вернёт 0
12 % 5;  // Вернёт 2
7 % 3;   // Вернёт 1
5.5 % 2; // Вернёт 1.5
```
Как это поможет в определении чётного или нечётного числа? Чётное число делится на 2 без остатка. Поэтому, если деление i % 2 возвращает 0 — число чётное, иначе число нечётное.

Напишем проверку с использованием **%** в нашем цикле.
```js
var sum = 0;

for (var i = 1; i <= 10; i++) {
  console.log('i: ' + i);

  // Проверку добавляйте сюда
  if (i % 2 === 0 ) {
      sum += 2;
      console.log('чётное число');
    } else {
        sum += 1;
        console.log('нечётное число');
      }
    

  console.log('sum: ' + sum);
}

```
```js
var totalPages = 6; // Всего страниц в документе
var consumptionTotal = 0; //общий расход краски на все страницы
var consumptionPerPage = 70;// расход краски на одну страницу (70 мг)

for (var page = 1; page <= totalPages; page++) {
  keks.print(page);
  consumptionTotal += consumptionPerPage;
  console.log(consumptionTotal);
}
```
### Экономим краску
```js
var totalPages = 6; // Всего страниц в документе

var consumptionTotal = 0; // Общий расход тонера
var consumptionPerPage = 70; // Расход краски на одну страницу
var economyMode = true;

for (var page = 1; page <= totalPages; page++) {
  keks.print(page);

  if (economyMode && page > 3) {
    consumptionTotal += consumptionPerPage * 0.5;
  } else {
    consumptionTotal += consumptionPerPage;
  }
  
  console.log(consumptionTotal);
}
```
### Поиск чётного числа
Оператор % или «остаток от деления» возвращает остаток от деления.

10 % 5;  // Вернёт 0

12 % 5;  // Вернёт 2

7 % 3;   // Вернёт 1

5.5 % 2; // Вернёт 1.5

Если остаток от деления числа на 2 равен 0 — число чётное, иначе нечётное

```js
var days = 9; // Дней в периоде
var evenDayAmount = 200; // Количество протеина в чётные дни
var oddDayAmount = 100; // Количество протеина в нечётные дни
var total = 0; // Общее количество протеина

for (var i = 1; i <= days; i++) {
    if (i % 2 === 0) {
      total += evenDayAmount;
      } else {
        total += oddDayAmount;
        }
      console.log(total);
  }
  
/*

Мяу! Программа должна считать сколько протеина я должен выпить за весь тренировочный период.

В чётные дни я пью 200 грамм. В нечётные 100 грамм.

Количество дней хранится в переменной days, количество протеина для приёма в чётный день — в переменной evenDayAmount, протеин в нечётный день — в переменной oddDayAmount, а результат необходимо записать в переменную total, которая уже задана.

*/
```

Вот текущий порядок команд в цикле:

Получаем результат броска.
Проверяем, что результат броска меньше нуля. Если это так, то переходим к шагу три, иначе к шагу четыре.
Пишем в консоль про промах и увеличиваем счётчик промахов на единицу.
Увеличиваем общий результат total и выводим результат броска в консоль.
Нам нужно, чтобы:

Проверка на общее количество промахов гарантированно выполнялась на каждом витке цикла.
По достижении трёх промахов игра бы сразу завершалась.

```js
var score = 0;
var total = 0;
var victoryPoints = 100;
var misses = 0;

while (total < victoryPoints) {
  if (misses >= 3) {
    break;
  }

  score = keks.getScore();

  if (score < 0) {
    console.log('Промах!');
    misses++;
  } else {
    total += score;
    console.log('Результат броска: ' + score);
  }
}

if (total >= victoryPoints) {
  console.log('Победа! Очков: ' + total + ', промахов: ' + misses)
  } else {
     console.log('Проигрыш. Очков: ' + total + ', промахов: ' + misses)
    }

```

```js
var initialWeight = 6000; // Исходный вес в граммах
var targetWeight = 5000; // Желанный вес в граммах
var currentWeight = initialWeight;//теперішня вага
var days = 0;

while (currentWeight > targetWeight) {
    var persent = currentWeight / 100 * 5; // 5% теперішньої ваги
    currentWeight = currentWeight - persent; // віднімаємо 5% він теперішньої ваги
    days ++;
  }

/*

Мяу! Меня утомляют диета и тренировки, поэтому я хочу узнать, сколько ещё дней осталось заниматься, чтобы добиться нужного веса к мероприятию.

Входные данные: вес в начале и вес в конце.

Логика работы: если я тренируюсь и сижу на диете, то теряю 5% своей массы в день (на сухом корме не особо пожируешь, а тренировки суровые).

Просто посчитай, сколько дней понадобится провести в таком режиме и запиши количество в переменную days.

*/
```

або 
```js
var initialWeight = 6000; // Исходный вес в граммах
var targetWeight = 5000; // Желанный вес в граммах
var currentWeight = initialWeight;//теперішня вага
var days = 0;

  while (currentWeight > targetWeight) {
    currentWeight = currentWeight * 0.95;
    days ++;
  }
```

 **Рефакторинг** — это переписывание программы, после которого она должна работать так же, но быть более гибкой. 

 ```js
 var usersByDay = [812, 1360, 657, 1247];
var index = 0;
console.log( usersByDay[index]);
index = 3;
console.log( usersByDay[index]);
```
### Массивы умеют рассказывать о своей длине.

 Для этого используется команда [].length, которое знает о количестве элементов в массиве:
```js
var numbers = [1, 2, 3, 4];

console.log(numbers.length);
// Выведет в консоль 4
```
С помощью обращения к length можно получить последний элемент массива, даже если вы не знаете, сколько элементов в нём хранится:
```js
someBigArray[someBigArray.length - 1];
```
### Останній елемент масива , 3 із кінця елемент масива
Во второй строке выведите в консоль длину массива usersByDay

На следующей строке выведите в консоль последний элемент массива: usersByDay[usersByDay.length - 1]

На следующей строке выведите в консоль третий с конца элемент массива, используя квадратные скобки и length

Теперь в первой строке, через запятую, добавьте в массив usersByDay пятый элемент 1000 и убедитесь, что вывод в консоль работает правильно.
```js
var usersByDay = [812, 1360, 657, 1247, 1000];
console.log(usersByDay.length);
console.log(usersByDay[usersByDay.length - 1]);
console.log(usersByDay[usersByDay.length - 3]);
```
```
5 (number)

1000 (number)

657 (number)

undefined (undefined)
```

### Как лучше писать условие выхода из цикла? 
Есть два варианта. Рассмотрим их на примере массива из трёх элементов:
```js
// Первый вариант: i < usersByDay.length
// usersByDay.length == 3

Подготовка: i = 0
1 итерация: i = 0; 0 < 3? да! действия первой итерации; i = 1
2 итерация: i = 1; 1 < 3? да! действия второй итерации; i = 2
3 итерация: i = 2; 2 < 3? да! действия третьей итерации; i = 3
4 итерация: i = 3; 3 < 3? нет! Завершаем цикл!
// Второй вариант: i <= usersByDay.length - 1
// usersByDay.length - 1 == 2

Подготовка: i = 0
1 итерация: i = 0; 0 <= 2? да! действия первой итерации; i = 1
2 итерация: i = 1; 1 <= 2? да! действия второй итерации; i = 2
3 итерация: i = 2; 2 <= 2? да! действия третьей итерации; i = 3
4 итерация: i = 3; 3 <= 2? нет! Завершаем цикл!
```
Оба варианта условия выхода, i < usersByDay.length и i <= usersByDay.length - 1, работают одинаково.

## Цикл масива
```js
var expectedUsers = 1000;

var usersByDay = [812, 1360, 657, 1247];

for (var i = 0; i <= usersByDay.length - 1; i++) {
  console.log(usersByDay[i]);
}
```
```
812 (number)

1360 (number)

657 (number)

1247 
```
## Сума всії значень у масиві
```js
var expectedUsers = 1000;

var usersByDay = [812, 1360, 657, 1247];

var totalUsers = 0;

for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}

console.log(totalUsers);
```

### Теперь программа стала намного гибче 
 Позволяет легко анализировать любые объёмы данных (за неделю, месяц, да хоть за год). Для этого нужно просто менять значения внутри массива ``usersByDay.``
```js
var expectedUsers = 1000;

var usersByDay = [817, 1370, 752, 1247, 681, 1120, 915, 1281, 875, 1341, 757, 610, 812, 1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1239, 812, 638, 877, 1242, 1159, 1372];

// Суммируем посещаемость
var totalUsers = 0;
for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}


// Рассчитываем среднее значение посещаемости
var averageUsers = totalUsers / usersByDay.length;


```
Сейчас проверим гипотезу. Вводим переменную с минимальной допустимой посещаемостью. Потом в цикле проверяем посещаемость за текущий день, и если она не дотягивает до минимальной, выводим её в консоль. 
```js
var expectedUsers = 1000;

var usersByDay = [817, 1370, 752, 1247, 681, 1120, 915, 1281, 875, 1341, 757, 610, 812, 1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1239, 812, 638, 877, 1242, 1159, 1372];

// Рисуем график посещаемости
keks.plot(usersByDay, expectedUsers);

// Суммируем посещаемость
var totalUsers = 0;
var minUsers = expectedUsers - 100;
for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
  // виводить числа котрі мене допустимого відвідування
  if (usersByDay[i] < minUsers) {
    console.log(usersByDay[i]);
    }
}
```
### Запись в массив по индексу
Предлагаю для прояснения картины собрать данные о провалах в новый массив и вывести его на второй график. Для этого придётся записывать данные в массив. Запись в массив происходит так же, как и чтение — через обращение к элементу с помощью квадратных скобок:
```js
var numbers = [];
var index = 1;

numbers[0] = 1;
numbers[index] = 2;

// Выведет [1,2]
console.log(numbers);
```
Обратите внимание, что если в массиве нет элемента под тем номером, под которым мы записываем, то этот элемент будет создан. До выполнения кода в массиве не было ни нулевого, ни первого элементов, но после того, как мы записали значения в эти позиции, элементы добавились в массив.

## arr[N] = V
це операція створення значення в масиві.

означає, що по індексу`` N`` створи значення `` V``

## “=“ завжди означає присвоєння значення
ліва частина від дорівнює набуває значення вказане по праву сторону від дорівнює

``ЦЕ = СТАНЕ_ЦИМ``

```
// Посещаемость в пятый день составила 681 человек.
// Разность ожидаемой посещаемости и фактической: 1000 - 681 = 319.
// Значит 319 человек — величина провала посещаемости в пятый день.
```
```js
var expectedUsers = 1000;

var usersByDay = [817, 1370, 752, 1247, 681, 1120, 915, 1281, 875, 1341, 757, 610, 812, 1170, 769, 1261, 845, 1289, 515, 1247, 845, 1311, 741, 1239, 812, 638, 877, 1242, 1159, 1372];

// Рисуем график посещаемости
keks.plot(usersByDay, expectedUsers);

// Суммируем посещаемость и анализируем провалы
var totalUsers = 0;
var minUsers = expectedUsers - 100;
// погані дні
var badDays = [];

// цикл довжини масива
for (var i = 0; i <= usersByDay.length - 1; i++) {
  // додаємо всі дні відвідування = сума
  totalUsers += usersByDay[i];
  // якщо за день було менше мінімума
  if (usersByDay[i] < minUsers) {
    // вичисляємо кількість промахів записумо їх до масиву
    badDays[i] = expectedUsers - usersByDay[i];
    // виводимо пустий масив
  } else {
    badDays[i] = 0;
  }
}

keks.plot(badDays, 100);
```
## Конспект «Массивы». 1 часть
**Массив** — тип данных, который представляет собой список элементов, у каждого из которых есть свой порядковый номер.

``В массиве можно хранить любые данные``: строки, булевы значения, числа и даже другие массивы.

``Нумерация элементов массива начинается с нуля``, поэтому порядковый номер (индекс) первого элемента равен нулю.

В качестве индекса можно использовать переменную.

Используйте команду ``[].length``, чтобы узнать длину массива (сколько в нём элементов). С её помощью можно получить последний элемент массива.
```js
var numbers = [1, 2, 3, 4, 5];
var index = 3;

console.log(numbers[0]);
// Выведет в консоль 1

console.log(numbers[index]);
// Выведет в консоль 4

console.log(numbers.length);
// Выведет в консоль 5

console.log(numbers[numbers.length - 1]);
// Выведет в консоль 5
```
Массивы можно перебирать в циклах. Например, цикл ниже выводит элементы массива в консоль по очереди и прекращает свою работу, когда i станет равно длине массива.
```js
var numbers = [1, 2, 3, 4, 5];

for (var i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}

// Выведет 1
// Выведет 2
// Выведет 3
// Выведет 4
// Выведет 5
Запись в массив происходит так же, как чтение, через квадратные скобки.

var numbers = [];
var index = 1;

numbers[0] = 1;
numbers[index] = 2;

console.log(numbers);
// Выведет в консоль [1,2]
```

```js
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];

// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];

// Раскодированное сообщение
var decodedMessage = '';

for (i = 0; i < encodedMessage.length; i++) {
  decodedMessage += symbols[encodedMessage[i]];
  }
/*

Мяу! Я научился шифровать и мне нужна программа расшифровки.

Есть массив symbols, в котором хранится алфавит (буквы и другие символы).

Есть массив encodedMessage, в котором хранится зашифрованное сообщение. Каждый элемент этого массива — это индекс символа из массива symbols.

Программа дешифровки должна переводить элементы из массива с шифровкой (encodedMessage) в символы из массива алфавита (symbols) и склеивать из них расшифрованную строку. Эту строку запиши в переменную decodedMessage.

*/
```
### Меняем элементы местами
```js
var usersByDay = [4, 1, 2, 3];
console.log(usersByDay);

var swap = usersByDay[0];

usersByDay[0] = usersByDay[1];
console.log(usersByDay);

 usersByDay[1] = swap;
 console.log(usersByDay);
 ```
 ### Ищем минимальный элемент
 ```js
 var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  
  if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      console.log('Новый минимальный элемент: ' + minValue);
    }
    
}

console.log('Минимальный элемент: ' + minValue);
```
### Начинаем сортировку
```js
var usersByDay = [4, 2, 1, 3];
console.log(usersByDay);

var currentIndex = 0;
var minValue = usersByDay[currentIndex];

for (var j = currentIndex + 1; j <= usersByDay.length - 1; j++) {
  if (usersByDay[j] < minValue) {
    minValue = usersByDay[j];
    var swap = usersByDay[currentIndex];
    usersByDay[currentIndex] = minValue;
    usersByDay[j] = swap;
    console.log('Меняю местами ' + swap + ' и ' + minValue);
    console.log('Массив сейчас: ' + usersByDay);
  }
}

console.log('Минимальный элемент: ' + minValue);
```
### Медиана на нечётном количестве элементов
```js
Медиана отличается от среднего значения устойчивостью к отклонениям:

// Среднее: 3
[1, 2, 3, 4, 5]
// Медиана: 3
[1, 2, 3, 4, 5]

// Среднее: 12
[1, 2, 3, 4, 50]
// Медиана: 3
[1, 2, 3, 4, 50]
Медиану легко получить у массива с нечётным количеством элементов. Для этого нужно правильно посчитать индекс среднего элемента. Попробуем вывести формулу:

// Длина массива 3, индекс среднего элемента 1
[1, 2, 3]

// Длина массива 5, индекс среднего элемента 2
[1, 2, 3, 4, 5]

// Длина массива 7, индекс среднего элемента 3
[1, 2, 3, 4, 5, 6, 7]
Вычитаем из длины массива единицу и делим на два, и индекс найден.

Кекс может присылать массивы данных разной длины, поэтому придётся проверять количество элементов на чётность и в зависимости от этого находить медиану. Для проверки на чётность используем уже знакомый оператор %.
```
## Example!!
```js
var usersByDay = ['a', 'b', 'c', 'd', 'i'];
console.log(usersByDay);
if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) /2;
  console.log(medianIndex);
  var median = usersByDay[medianIndex];
  console.log(median);
  }
  ```
  ```
  ["a", "b", "c", "d", "i"] (array)

  2 (number)

  "c" (string)

  undefined (undefined)
  ```
  ### Медиана на чётном количестве элементов
  Если количество элементов чётное, то медиана считается как среднее значение от двух элементов: левого и правого от середины.
  ```
  // Медиана: 3
[0, 1, 2, 4, 50, 100]
Снова выводим формулы индексов двух элементов: левого и правого от середины.

// Длина 4, индекс левого 1, правого 2
[1, 2, 3, 4]

// Длина 6, индекс левого 2, правого 3
[1, 2, 3, 4, 5, 6]

// Длина 8, индекс левого 3, правого 4
[1, 2, 3, 4, 5, 6, 7, 8]
```
Делим длину массива на два и вычитаем единицу — левый индекс найден. Делим длину массива на два — правый индекс найден.

Расчёт медианы для чётного количества элементов в массиве добавляем в альтернативной ветке условия.
```js
var usersByDay = [1, 2, 3, 4, 5, 6];
console.log(usersByDay);

if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) / 2;
  console.log(medianIndex);
  var median = usersByDay[medianIndex];
  console.log(median);
} else {
  var leftIndex = usersByDay.length / 2 - 1;
  var rightIndex = usersByDay.length / 2;
  console.log(leftIndex);
  console.log(rightIndex);
  var median =  (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
  console.log(median);
  }
```
```
[1, 2, 3, 4, 5, 6] (array)

2 (number)

3 (number)

3.5 (number)

undefined (undefined)
```

```js
var expectedUsers = 1000;

var usersByDay = [817, 581, 1370, 752, 1247, 681, 1120, 915, 875, 1341, 757, 610, 812, 741, 1139, 812, 638, 877, 1242, 1159, 1372, 1170, 845, 1289, 515, 1247, 769, 1261, 2805, 1201];

// Рисуем график посещаемости
keks.plot(usersByDay, expectedUsers);

// Суммируем посещаемость
var totalUsers = 0;
for (var i = 0; i <= usersByDay.length - 1; i++) {
  totalUsers += usersByDay[i];
}

// Рассчитываем среднее значение посещаемости
var averageUsers = totalUsers / usersByDay.length;
console.log('Средняя посещаемость: ' + averageUsers);

if (averageUsers > expectedUsers) {
  console.log('Посещаемость великолепна. Продолжай в том же духе!');
} else {
  console.log('Посещаемость так себе. Нужно поднапрячься!');
}

// Сортируем массив

for (var i = 0; i <= usersByDay.length - 2; i++) {
  var minValue = usersByDay[i];

  for (var j = i + 1; j <= usersByDay.length - 1; j++) {
    if (usersByDay[j] < minValue) {
      minValue = usersByDay[j];
      var swap = usersByDay[i];
      usersByDay[i] = minValue;
      usersByDay[j] = swap;
    }
  }
}


// Рассчитываем медиану

if (usersByDay.length % 2 !== 0) {
  var medianIndex = (usersByDay.length - 1) / 2;
  var median = usersByDay[medianIndex];
} else {
  var leftIndex = usersByDay.length / 2 - 1;
  var rightIndex = usersByDay.length / 2;
  var median = (usersByDay[leftIndex] + usersByDay[rightIndex]) / 2;
}
console.log('Медианная посещаемость: ' + median);

```

### Осталось понять, как посчитать проценты.

Для этого нужно поделить значение медианы на среднее значение. Например, если медиана составляет 80, а среднее значение 100, то:

// Медиана составляет 80% от среднего
80 / 100 = 0.8
## Цікаво!!
```js
// Квалификационное значение 
var qualificationDistance = 200;
// длины прыжков
var attempts = [120, 150, 160, 201, 203, 180, 202];
console.log(attempts);
// три лучших прыжка;посчитать среднее значение этих трёх прыжков

attempts.sort(function(a,b){
  return b - a;
});

var threeBest = attempts.slice(0, 3);
console.log(threeBest);

var sum = threeBest.reduce(function(acc, num){
  return acc + num;
});
console.log(sum);

var averageBest = sum / threeBest.length;
console.log(averageBest);

//  прошёл квалификацию/сли квалификация не пройдена
var qualified = averageBest > qualificationDistance;

console.log(qualified);

/*

Мяу! Я провожу тренировки и хочу понять, пройду ли квалификацию.

В течение тренировки я делаю несколько прыжков, и собираю длины прыжков в массив attempts.

Программа должна выбрать три лучших прыжка, а затем посчитать среднее значение этих трёх прыжков и записать его в переменную averageBest.

Квалификационное значение хранится в переменной qualificationDistance.

Если среднее от лучших трёх прыжков больше квалификационного значения, то я прошёл квалификацию и переменная qualified должна содержать true. Если квалификация не пройдена, то в qualified должно быть false.

*/
```

### Функція
```js 
var calculateMiles = function (distance) {

  var percent = 0.25;
  if (distance > 10500) {
    percent = 0.35;
  }
  var miles = distance * percent;
  console.log('За полёт получим ' + miles + ' миль');
};

calculateMiles(4125);
calculateMiles (11000);

```
Что значит возвращать? Функция может выполнить код и отдать результат своих действий. Этот результат подставится в то место, где мы вызвали функцию.

Для этого используется оператор return. После оператора надо указать возвращаемое значение. Тогда функция дойдёт до строки с return, вернёт результат своей работы и закончит выполнение кода, иными словами произойдёт выход из функции.
### Возвращение из функции
Объявим функцию, которая будет возвращать сумму числа 2 и ещё какого-то числа.
```js
var increaseByTwo = function (number) {
  var sum = 2 + number;
  return sum;
};

increaseByTwo(1); // Функция вернёт 3
increaseByTwo(2); // Функция вернёт 4
increaseByTwo(4); // Функция вернёт 6
```
increaseByTwo сложит значения и вернёт полученный результат.

Несколько вещей, которые нужно знать:

Код, написанный на новой строке после return, не выполняется.
Функция не может вернуть сразу много значений, она возвращает только один результат.
Если внутри функции нет return или после return не указано возвращаемое значение, функция вернёт undefined, иными словами, ничего.
В JavaScript есть встроенные функции языка, которые возвращают результат своей работы. Таких функций очень много, вот несколько из них:

Math.ceil(number) — принимает на вход число и округляет его до целого в большую сторону.
Math.floor(number) — делает то же самое, только округляет в меньшую сторону.
Math.round(number) — округляет число до ближайшего целого значения.

!!!
```js
var calculateSalary = function (index) {
  var percentage = index >= 100000 ? 0.45 : 0.35;

  var nalog = index * percentage;
  
  return index - nalog;
};

console.log(calculateSalary(90000));

/*

Мяу! Мне нужна программа, которая от «грязной» зарплаты (зарплата до вычета налогов) посчитает примерную «чистую» зарплату (которая выдаётся на лапы).

Оформи программу в виде функции calculateSalary c одним параметром — величиной грязной зарплаты. Функция должна возвращать чистую зарплату.

Большая точность мне не нужна, просто считаем, что 35% величины грязной зарплаты составляют налоги, а если грязная зарплата больше или равна 100 тысячам, то налоги составляют уже 45%.

*/
```

aбо
```js
var calculateSalary = function (index) {
  var percentage = 0.35;
  
  if (index >= 100000) {
    percentage = 0.45;
  }
  
  var nalog = index * percentage;
  
  return index - nalog;
};

console.log(calculateSalary(90000));
```

## Об'єкт
Чтобы получить значение свойства, к нему надо обратиться через точку объект.ключ. Такая запись называется точечной нотацией и возвращает значение свойства объекта, если такое свойство есть. В противном случае вы получите undefined, то есть ничего. На практике это выглядит так:
```js
var cat = {
  name: 'Кекс',
  age: 5
};
console.log(cat.name); // Выведет в консоль 'Кекс'
console.log(cat.age); // Выведет в консоль 5
console.log(cat.color); // Выведет undefined, такого ключа в объекте нет
```